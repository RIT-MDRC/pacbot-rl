from typing import Callable, Literal, Mapping, Optional

import numpy as np
from numpy.typing import NDArray

class PacmanGymConfiguration:
    pass

class PacmanGym:
    def __init__(self) -> None: ...
    def reset(self, config: PacmanGymConfiguration) -> None: ...
    def step(self, action: int) -> tuple[int, bool]: ...
    def score(self) -> int: ...
    def lives(self) -> int: ...
    def is_done(self) -> bool: ...
    def first_ai_done(self) -> bool: ...
    def all_ghosts_freed(self) -> bool: ...
    def all_ghosts_not_frightened(self) -> bool: ...
    def are_ghosts_close(self) -> bool: ...
    def remaining_pellets(self) -> int: ...
    def action_mask(self) -> list[bool]: ...
    def purgatory_action_mask(self) -> list[bool]: ...
    def obs_numpy(self, config: PacmanGymConfiguration) -> np.ndarray: ...
    def print_game_state(self) -> None: ...
    @property
    def random_start(self) -> bool: ...

EvaluatorFunc = Callable[
    [NDArray[np.float32], NDArray[np.bool_]],
    tuple[NDArray[np.float32], NDArray[np.float32]],
]

# class MCTSContext:
#     def __init__(self, env: PacmanGym, evaluator: EvaluatorFunc) -> None: ...
#     def reset(self) -> None: ...
#     def take_action(self, action: int) -> tuple[int, bool]: ...
#     def best_action(self) -> int: ...
#     def action_distribution(self) -> list[float]: ...
#     def policy_prior(self) -> list[float]: ...
#     def action_values(self) -> list[float]: ...
#     def value(self) -> float: ...
#     def ponder_and_choose(self, max_tree_size: int) -> int: ...
#     def max_depth(self) -> int: ...
#     def node_count(self) -> int: ...
#     def root_obs_numpy(self) -> np.ndarray: ...
#     @property
#     def env(self) -> PacmanGym: ...
#     evaluator: EvaluatorFunc
